# -*- coding: utf-8 -*-
"""ES_CW1_Triangulations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13efzHhQ7WuGwn_yhFUqNmSoyuuTX1ITi
"""

import numpy as np
import math
import random

"""# Geometric functions"""

def radius(FWI):
  return -11.242*FWI +101.88

#define Circle data struct:
class Circle:
  def __init__(self, x, y, r):
    self.x = x
    self.y = y
    self.r = r

#define Cartesian Coordinate data struct:
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y

#function to find euclidean distance between 2 points:
#WORKS!
def EuclideanDistance(point1, point2):
  d = np.power(((point1.x - point2.x)**2 + (point1.y - point2.y)**2),0.5) 
  return d

#function to get intersection points of 2 circles:
#WORKS
def getIntersection_2_circles(circle1, circle2):
  
  d = EuclideanDistance(Point(circle1.x,circle1.y), Point(circle2.x,circle2.y))

  # non intersecting
  if d > circle1.r + circle2.r :
      return None
  # One circle within other
  if d < np.absolute(circle1.r-circle2.r):
      return None
  # coincident circles
  if d == 0 and circle1.r == circle2.r:
      return None
  else:
      a=(circle1.r**2-circle2.r**2+d**2)/(2*d)
      h=np.power(circle1.r**2-a**2, 0.5)
      x2=circle1.x+a*(circle2.x-circle1.x)/d   
      y2=circle1.y+a*(circle2.y-circle1.y)/d   
      x3=x2+h*(circle2.y-circle1.y)/d     
      y3=y2-h*(circle2.x-circle1.x)/d 

      x4=x2-h*(circle2.y-circle1.y)/d
      y4=y2+h*(circle2.x-circle1.x)/d
      
      point1 = Point(x3, y3)
      point2 = Point(x4, y4)

      return ([point1, point2])

#function to determine number of intersection points between 2 circles:
#WORKS - DOESNT WORK FOR 1 INTERSECTION, but that is never the case for each of the edge cases
def number_of_intersections(circle1, circle2):
  v = getIntersection_2_circles(circle1, circle2)
  if v == None:
    return 0
  else:
    return len(v)

#function to determine if 1 circle is contained within another:
  #more specifically, arg circle1 is contained in arg circle2
#WORKS BUT NOT FOR TOUCHING
def containment_2_circles(circle1, circle2):  #return 1 if True and 0 if False
  d=np.power((circle2.x-circle1.x)**2 + (circle2.y-circle1.y)**2, 0.5)
  numberOfIntersections = number_of_intersections(circle1, circle2)
  if (d < np.absolute(circle1.r-circle2.r)) and (circle1.r < circle2.r) and (numberOfIntersections == 0) :
    return 1
  else:
    return 0

#function to determine if a point is contained within a circle:
def point_in_circle(point, circle): #point and circle arguments are their data structs respectively
  #return 1 if True and 0 if False
  if (point.x-circle.x)**2 + (point.y-circle.y)**2 < circle.r**2:
    return 1
  else:
    return 0

#function to determine case of 3 circles overlapping:
  #note:  determineOverlapCase_intermediate is an intermediate function that is called in the determineOverlapCase function 6 times
  #       to then determine which configuration of arguments yields a valid Case
def determineOverlapCase_intermediate(circle1, circle2, circle3):

  #check containment conditions:
  _1_containedIn_2 = containment_2_circles(circle1, circle2)
  _1_containedIn_3 = containment_2_circles(circle1, circle3)
  _2_containedIn_1 = containment_2_circles(circle2, circle1)
  _2_containedIn_3 = containment_2_circles(circle2, circle3)
  _3_containedIn_1 = containment_2_circles(circle3, circle1)
  _3_containedIn_2 = containment_2_circles(circle3, circle2)

  #check intersection numbers:
  intersections_between_1and2 = number_of_intersections(circle1, circle2)
  intersections_between_1and3 = number_of_intersections(circle1, circle3)
  intersections_between_2and3 = number_of_intersections(circle2, circle3)

  conditions = [_1_containedIn_2, _1_containedIn_3, _2_containedIn_1, _2_containedIn_3, _3_containedIn_1, _3_containedIn_2, intersections_between_1and2, intersections_between_1and3, intersections_between_2and3]

  #match condition to case: (using if-elif-statements instead of dictionary but maybe use hashmap when translating to js)
  if conditions == [0, 0, 0, 0, 0, 0, 0, 0, 0]:
    Case = 1
  elif conditions == [0, 0, 0, 0, 0, 0, 2, 0, 2]:
    Case = 2
  elif conditions == [1, 0, 0, 0, 0, 0, 0, 0, 0]:
    Case = 3
  elif conditions == [1, 1, 0, 1, 0, 0, 0, 0, 0]:
    Case = 4
  elif conditions == [0, 1, 0, 1, 0, 0, 2, 0, 0]:
    Case = 5
  elif conditions == [0, 1, 0, 1, 0, 0, 0, 0, 0]:
    Case = 6
  elif conditions == [0, 0, 0, 0, 0, 0, 0, 0, 2]:
    Case = 7
  elif conditions == [0, 0, 0, 0, 0, 0, 2, 2, 2]:

  #Differentiate between cases 8,9,13 and 14:
  #.................
  #Case 8: one of the intersection points between 2 circles is contained within the third circle
  #Case 9: none of the intersection points between 2 circles is contained within the third circle
  #Case 13: intersections between 1 and 2 both contained within 3 and intersections between 1 and 3 both contained within 2 
    #but intersections between 2 and 3 not contained within 1
  #Case 14: Case 9 but intersections between 1 and 3 contained within 2
  #.................

    intersections_1and2 = getIntersection_2_circles(circle1, circle2)
    intersections_1and3 = getIntersection_2_circles(circle1, circle3)
    intersections_2and3 = getIntersection_2_circles(circle2, circle3)

    if (point_in_circle(intersections_1and2[0], circle3) == 0 and
        point_in_circle(intersections_1and2[1], circle3) == 0 and
        point_in_circle(intersections_2and3[0], circle1) == 0 and
        point_in_circle(intersections_2and3[1], circle1) == 0):
      if (point_in_circle(intersections_1and3[0], circle2) == 0 and
          point_in_circle(intersections_1and3[1], circle2) == 0):
        Case = 9
      else:
        Case = 14
    elif (point_in_circle(intersections_1and2[0], circle3) == 1 and
        point_in_circle(intersections_1and2[1], circle3) == 1 and
        point_in_circle(intersections_1and3[0], circle2) == 1 and
        point_in_circle(intersections_1and3[1], circle2) == 1 and
        point_in_circle(intersections_2and3[0], circle1) == 0 and
        point_in_circle(intersections_2and3[1], circle1) == 0):
      Case = 13
    else:
      Case = 8



  # elif conditions == [0, 0, 0, 0, 0, 0, 0, 0, 0]:
  #   Case = 9
  elif conditions == [1, 0, 0, 0, 0, 0, 0, 0, 2]:
    Case = 10
  elif conditions == [1, 0, 0, 0, 0, 0, 0, 2, 2]:
    Case = 11
  elif conditions == [1, 1, 0, 0, 0, 0, 0, 0, 2]:
    Case = 12
  # elif conditions == [0, 0, 0, 0, 0, 0, 0, 0, 0]:
  #   Case = 13
  # elif conditions == [0, 0, 0, 0, 0, 0, 0, 0, 0]:
  #   Case = 14
  else:
    Case = 0  #Inconclusive, must switch up circle assignments

  return Case

def determineOverlapCase(circle1, circle2, circle3):
  #Cycle through 6 possible argument combinations to get a conclusive output
  Case = determineOverlapCase_intermediate(circle1, circle2, circle3)
  circle_config = 1


  if Case == 0 or Case == 8:  #Case 8 is inconclusive and can lead to Case 13 not being determined properly so need to iterate 
                              #(Case 13 can satisfy the conditions for Case 8 in up to 4 configurations...)
    Case = determineOverlapCase_intermediate(circle1, circle3, circle2)
    circle_config = 2
  if Case == 0 or Case == 8:
    Case = determineOverlapCase_intermediate(circle2, circle1, circle3)
    circle_config = 3
  if Case == 0 or Case == 8:
    Case = determineOverlapCase_intermediate(circle3, circle1, circle2)
    circle_config = 4
  if Case == 0 or Case == 8:
    Case = determineOverlapCase_intermediate(circle2, circle3, circle1)
    circle_config = 5
  if Case == 0 or Case == 8:
    Case = determineOverlapCase_intermediate(circle3, circle2, circle1)
    circle_config = 6
  return Case, circle_config

#Area of circle:
def area_circle(circle):
  A = math.pi * (circle.r)**2
  return A


def area_overlap_2circles(circle1, circle2):
  intersections = getIntersection_2_circles(circle1, circle2)

  d = EuclideanDistance(intersections[0], intersections[1])

  #area of segment 1:

  r1 = circle1.r
  theta1 = np.arccos((2*r1**2 - (d**2)) / (2*r1**2))

  a_sect1 = (theta1/(2*math.pi))*math.pi*(r1**2)
  a_tri1 = 0.5 * (r1**2) * np.sin(theta1)

  a_seg1 = a_sect1-a_tri1

  #area of segment 2:

  r2 = circle2.r
  theta2 = np.arccos((2*r2**2 - (d**2)) / (2*r2**2))

  a_sect2 = (theta2/(2*math.pi))*math.pi*(r2**2)
  a_tri2 = 0.5 * (r2**2) * np.sin(theta2)

  a_seg2 = a_sect2-a_tri2

  return a_seg1 + a_seg2

"""# **Case-by-case functions: Computes individual areas**"""

#Case 1:
def areas_case1 (circle1, circle2, circle3):

  #total area (all green) is just the total area of the 3 circles:
  A1 = area_circle(circle1)
  A2 = area_circle(circle2)
  A3 = area_circle(circle3)

  return [[A1, A2, A3, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]]

#Case 2:
def areas_case2 (circle1, circle2, circle3):
  #calculate yellow overlapping areas first then calculate green areas accordingly
  yellow_1and2 = area_overlap_2circles(circle1, circle2)
  yellow_1and3 = area_overlap_2circles(circle2, circle3)

  green1 = area_circle(circle1)
  green1 -= yellow_1and2
  green2 = area_circle(circle2)
  green2 -= yellow_1and2 + yellow_1and3
  green3 = area_circle(circle3)
  green3 -= yellow_1and3

  total_yellow = yellow_1and2 + yellow_1and3
  total_green = green1 + green2 + green3
  
  return [[green1, green2, green3, 0],
          [yellow_1and2, yellow_1and3, 0, 0],
          [0, 0, 0, 0]]

#Case 3:
def areas_case3 (circle1, circle2, circle3):
  yellow = area_circle(circle1)
  
  green1 = area_circle(circle2)
  green1 -= yellow
  green2 = area_circle(circle3)

  return [[green1, green2, 0, 0],
          [yellow, 0, 0, 0],
          [0, 0, 0, 0]]

#Case 4:
def areas_case4 (circle1, circle2, circle3):
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  red = a1
  yellow = a2 - a1
  green = a3 - a2

  return [[green, 0, 0, 0],
          [yellow, 0, 0, 0],
          [red, 0, 0, 0]]

#Case 5:
def areas_case5 (circle1, circle2, circle3):
  red = area_overlap_2circles(circle1, circle2)
  
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)

  yellow1 = a1 - red
  yellow2 = a2 - red


  green = area_circle(circle3)
  green -= yellow1 + yellow2 + red

  return [[green, 0, 0, 0],
          [yellow1, yellow2, 0, 0],
          [red, 0, 0, 0]]

#Case 6:
def areas_case6 (circle1, circle2, circle3):
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)

  yellow = a1 + a2

  green = area_circle(circle3)
  green -= yellow

  return [[green, 0, 0, 0],
          [a1, a2, 0, 0],
          [0, 0, 0, 0]]

#Case 7:
def areas_case7 (circle1, circle2, circle3):
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  yellow = area_overlap_2circles(circle2, circle3)

  a2 -= yellow
  a3 -= yellow

  a1 = area_circle(circle1)

  return [[a1, a2, a3, 0],
          [yellow, 0, 0, 0],
          [0, 0, 0, 0]]

#Case 8:
def areas_case8 (circle1, circle2, circle3):
#Bugging; negative green values

  #Find intersections of each circle pair
  intersections_1and2 = getIntersection_2_circles(circle1, circle2)
  intersections_1and3 = getIntersection_2_circles(circle1, circle3)
  intersections_2and3 = getIntersection_2_circles(circle2, circle3)

  #Find the vertices of the red polygon
  if (point_in_circle(intersections_1and2[0], circle3)) == 0:
    polygon_vertex_a = intersections_1and2[1]
  elif (point_in_circle(intersections_1and2[1], circle3)) == 0:
    polygon_vertex_a = intersections_1and2[0]

  if (point_in_circle(intersections_1and3[0], circle2)) == 0:
    polygon_vertex_b = intersections_1and3[1]
  elif (point_in_circle(intersections_1and3[1], circle2)) == 0:
    polygon_vertex_b = intersections_1and3[0]

  if (point_in_circle(intersections_2and3[0], circle1)) == 0:
    polygon_vertex_c = intersections_2and3[1]
  elif (point_in_circle(intersections_2and3[1], circle1)) == 0:
    polygon_vertex_c = intersections_2and3[0]

  #Find area of polygon using sine rule -> cosine rule
  polygon_side_a = EuclideanDistance(polygon_vertex_a, polygon_vertex_b)
  polygon_side_b = EuclideanDistance(polygon_vertex_a, polygon_vertex_c)
  polygon_side_c = EuclideanDistance(polygon_vertex_b, polygon_vertex_c)

  angle = np.arccos((polygon_side_b**2 + polygon_side_c**2 - polygon_side_a**2) / (2*polygon_side_b*polygon_side_c))

  polygon_area = 0.5 * polygon_side_b * polygon_side_c * np.sin(angle) #UNIT TESTED: CORRECT

  #Find area of each segment:
    #Segment of circle 1: polygon_vertices b & a | radii: polygon_side b & c | opposite chord: polygon_side_a
    #Segment of circle 2: polygon_vertices c & a | radii: polygon_side c & a | opposite chord: polygon_side_b
    #Segment of circle 3: polygon_vertices c & b | radii: polygon_side a & b | opposite chord: polygon_side_c

  angle1 = np.arccos((circle1.r**2 + circle1.r**2 - polygon_side_a**2) / (2*(circle1.r**2)))
  area_sector1 = (angle1/(2*math.pi)) * math.pi * (circle1.r**2)
  area_triangle1 = 0.5 * (circle1.r**2) * np.sin(angle1)
  area_segment1 = area_sector1 - area_triangle1

  angle2 = np.arccos((circle2.r**2 + circle2.r**2 - polygon_side_b**2) / (2*(circle2.r**2)))
  area_sector2 = (angle2/(2*math.pi)) * math.pi * (circle2.r**2)
  area_triangle2 = 0.5 * (circle2.r**2) * np.sin(angle2)
  area_segment2 = area_sector2 - area_triangle2

  angle3 = np.arccos((circle3.r**2 + circle3.r**2 - polygon_side_c**2) / (2*(circle3.r**2)))
  area_sector3 = (angle3/(2*math.pi)) * math.pi * (circle3.r**2)
  area_triangle3 = 0.5 * (circle3.r**2) * np.sin(angle3)
  area_segment3 = area_sector3 - area_triangle3

  #Can now sum the total red area
  red = polygon_area + area_segment1 + area_segment2 + area_segment3

  i1and2 = area_overlap_2circles(circle1, circle2)
  i1and3 = area_overlap_2circles(circle1, circle3)
  i2and3 = area_overlap_2circles(circle2, circle3)

  a1 = area_circle(circle1)
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  yellow_1 = i1and2 - red
  yellow_2 = i2and3 - red
  yellow_3 = i1and3 - red

  green_1 = a1 - (yellow_1 + yellow_3 + red)
  green_2 = a2 - (yellow_1 + yellow_2 + red)
  green_3 = a3 - (yellow_2 + yellow_3 + red)


  return [[green_1, green_2, green_3, 0],
          [yellow_1, yellow_2, yellow_3, 0],
          [red, 0, 0, 0]]



#Case 9:
def areas_case9 (circle1, circle2, circle3):
  y1 = area_overlap_2circles(circle1, circle2)
  y2 = area_overlap_2circles(circle2, circle3)
  y3 = area_overlap_2circles(circle1, circle3)

  a1 = area_circle(circle1)
  a1 -= y1 + y3
  a2 = area_circle(circle2)
  a2 -= y1 + y2
  a3 = area_circle(circle3)
  a3 -= y2 + y3

  green = a1 + a2 + a3
  yellow = y1 + y2 + y3

  return [[a1, a2, a3, 0],
          [y1, y2, y3, 0],
          [0, 0, 0, 0]]

#Case 10:
def areas_case10 (circle1, circle2, circle3):
  yellow1 = area_circle(circle1)
  yellow2 = area_overlap_2circles(circle2, circle3)

  green1 = area_circle(circle2)
  green2 = area_circle(circle3)

  green1 -= yellow1 + yellow2
  green2 -= yellow2

  return [[green1, green2, 0, 0],
          [yellow1, yellow2, 0, 0],
          [0, 0, 0, 0]]

#Case 11:
def areas_case11 (circle1, circle2, circle3):
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  i1and3 = area_overlap_2circles(circle1, circle3)
  i2and3 = area_overlap_2circles(circle2, circle3)

  red = i1and3

  yellow1 = a1 - red
  yellow2 = i2and3 - red

  green1 = a2 - (yellow1 + yellow2 + red)
  green2 = a3 - (yellow2 + red)

  return [[green1, green2, 0, 0],
          [yellow1, yellow2, 0, 0],
          [red, 0, 0, 0]]

#Case 12:
def areas_case12 (circle1, circle2, circle3):
  red = area_circle(circle1)

  yellow = area_overlap_2circles(circle2, circle3)
  
  green1 = area_circle(circle2)
  green1 -= yellow

  green2 = area_circle(circle3)
  green2 -=yellow

  yellow -= red

  return [[green1, green2, 0, 0],
          [yellow, 0, 0, 0],
          [red, 0, 0, 0]]

#Case 13: 
def areas_case13 (circle1, circle2, circle3):
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  i1and2 = area_overlap_2circles(circle1, circle2)
  i1and3 = area_overlap_2circles(circle1, circle3)
  i2and3 = area_overlap_2circles(circle2, circle3)

  left = a1 - i1and3  #y4
  right = a1 - i1and2 #y2

  intersections_2and3 = getIntersection_2_circles(circle2, circle3)

  intersections_1and2 = getIntersection_2_circles(circle1, circle2)
  intersections_1and3 = getIntersection_2_circles(circle1, circle3)

  #---------------
  #Find red using the same approach to find Red in Case 8 (polygon + 4 subtensions)

    #Setting up the red polygon vertices to be:
      #a  #b
      #c  #d

  if (intersections_1and3[0].y > intersections_1and3[1].y):
    polygon_red_vertex_a = intersections_1and3[0]
    polygon_red_vertex_c = intersections_1and3[1]
  else:
    polygon_red_vertex_a = intersections_1and3[1]
    polygon_red_vertex_c = intersections_1and3[0]

  if (intersections_1and2[0].y > intersections_1and2[1].y):
    polygon_red_vertex_b = intersections_1and2[0]
    polygon_red_vertex_d = intersections_1and2[1]
  else:
    polygon_red_vertex_b = intersections_1and2[1]
    polygon_red_vertex_d = intersections_1and2[0]

    #Find the area of the quadrilateral by splitting into 2 triangles: CAB and BDC

  polygon_red_side_ab = EuclideanDistance(polygon_red_vertex_a, polygon_red_vertex_b)
  polygon_red_side_bd = EuclideanDistance(polygon_red_vertex_b, polygon_red_vertex_d)
  polygon_red_side_cd = EuclideanDistance(polygon_red_vertex_c, polygon_red_vertex_d)
  polygon_red_side_ac = EuclideanDistance(polygon_red_vertex_a, polygon_red_vertex_c)
  polygon_red_side_bc = EuclideanDistance(polygon_red_vertex_b, polygon_red_vertex_c)
  
  angle_CAB = np.arccos( (polygon_red_side_ac**2 + polygon_red_side_ab**2 - polygon_red_side_bc**2) / (2 * polygon_red_side_ac * polygon_red_side_ab) )
  angle_BDC = np.arccos( (polygon_red_side_bd**2 + polygon_red_side_cd**2 - polygon_red_side_bc**2) / (2 * polygon_red_side_bd * polygon_red_side_cd) )

  area_triangle_CAB = 0.5 * polygon_red_side_ac * polygon_red_side_ab * np.sin(angle_CAB)
  area_triangle_BDC = 0.5 * polygon_red_side_bd * polygon_red_side_bc * np.sin(angle_BDC)

  area_red_polygon = area_triangle_CAB + area_triangle_BDC


    #Find areas of segments of circle 1, subtended from chords ab and cd:

  angle_a_c1_b = np.arccos( (2*circle1.r**2 - polygon_red_side_ab**2) / (2*circle1.r**2))
  angle_c_c1_d = np.arccos( (2*circle1.r**2 - polygon_red_side_cd**2) / (2*circle1.r**2))
  
  area_segment_ab = 0.5 * circle1.r**2 * (angle_a_c1_b - np.sin(angle_a_c1_b))
  area_segment_cd = 0.5 * circle1.r**2 * (angle_c_c1_d - np.sin(angle_c_c1_d))
  
    #Find area of segment of circle 2, subtended from chord bd:

  angle_b_c2_d = np.arccos( (2*circle2.r**2 - polygon_red_side_bd**2) / (2*circle2.r**2))
  area_segment_bd = 0.5 * circle2.r**2 * (angle_b_c2_d - np.sin(angle_b_c2_d))

    #Find area of segment of circle 3, subtended from chord ac:

  angle_a_c3_c = np.arccos( (2*circle3.r**2 - polygon_red_side_ac**2) / (2*circle3.r**2))
  area_segment_ac = 0.5 * circle3.r**2 * (angle_a_c3_c - np.sin(angle_a_c3_c))

  red = area_red_polygon + area_segment_ab + area_segment_cd + area_segment_bd + area_segment_ac

  #==============

  #-----------
  #Finding y1 (:= top) and y3 (:= bottom) using the same approach to find Red in Case 8 (polygon + 3 subtensions)

  #"Top" Reuleaux triangle:

  polygon_top_vertex_a = intersections_2and3[0]

  if EuclideanDistance(intersections_1and3[0], polygon_top_vertex_a) < EuclideanDistance(intersections_1and3[1], polygon_top_vertex_a):
    polygon_top_vertex_b = intersections_1and3[0]
  else:
    polygon_top_vertex_b = intersections_1and3[1]

  if EuclideanDistance(intersections_1and2[0], polygon_top_vertex_a) < EuclideanDistance(intersections_1and2[1], polygon_top_vertex_a):
    polygon_top_vertex_c = intersections_1and2[0]
  else:
    polygon_top_vertex_c = intersections_1and2[1]

  polygon_top_side_ab = EuclideanDistance(polygon_top_vertex_a, polygon_top_vertex_b)
  polygon_top_side_ac = EuclideanDistance(polygon_top_vertex_a, polygon_top_vertex_c)
  polygon_top_side_bc = EuclideanDistance(polygon_top_vertex_b, polygon_top_vertex_c)

  polygon_top_angle = np.arccos( (polygon_top_side_ab**2 + polygon_top_side_ac**2 - polygon_top_side_bc**2) / (2 * polygon_top_side_ab * polygon_top_side_ac) )
  
  polygon_top_area = 0.5 * polygon_top_side_ab * polygon_top_side_ac * np.sin(polygon_top_angle)
  
  #"Top" segments:

  segment_angle_top_circle1 = np.arccos( (2*circle1.r**2 - polygon_top_side_bc**2) / (2*circle1.r**2) )
  segment_angle_top_circle2 = np.arccos( (2*circle2.r**2 - polygon_top_side_ac**2) / (2*circle2.r**2) )
  segment_angle_top_circle3 = np.arccos( (2*circle3.r**2 - polygon_top_side_ab**2) / (2*circle3.r**2) )

  segment_area_top_circle1 = 0.5 * circle1.r**2 * (segment_angle_top_circle1 - np.sin(segment_angle_top_circle1))
  segment_area_top_circle2 = 0.5 * circle2.r**2 * (segment_angle_top_circle2 - np.sin(segment_angle_top_circle2))
  segment_area_top_circle3 = 0.5 * circle3.r**2 * (segment_angle_top_circle3 - np.sin(segment_angle_top_circle3))
  
  top = polygon_top_area - segment_area_top_circle1 + segment_area_top_circle2 + segment_area_top_circle3
  
  #----

  #"Bottom" Reuleaux triangle:

  polygon_bottom_vertex_a = intersections_2and3[1]

  if EuclideanDistance(intersections_1and3[0], polygon_bottom_vertex_a) < EuclideanDistance(intersections_1and3[1], polygon_bottom_vertex_a):
    polygon_bottom_vertex_b = intersections_1and3[0]
  else:
    polygon_bottom_vertex_b = intersections_1and3[1]

  if EuclideanDistance(intersections_1and2[0], polygon_bottom_vertex_a) < EuclideanDistance(intersections_1and2[1], polygon_bottom_vertex_a):
    polygon_bottom_vertex_c = intersections_1and2[0]
  else:
    polygon_bottom_vertex_c = intersections_1and2[1]

  polygon_bottom_side_ab = EuclideanDistance(polygon_bottom_vertex_a, polygon_bottom_vertex_b)
  polygon_bottom_side_ac = EuclideanDistance(polygon_bottom_vertex_a, polygon_bottom_vertex_c)
  polygon_bottom_side_bc = EuclideanDistance(polygon_bottom_vertex_b, polygon_bottom_vertex_c)

  polygon_bottom_angle = np.arccos( (polygon_bottom_side_ab**2 + polygon_bottom_side_ac**2 - polygon_bottom_side_bc**2) / (2 * polygon_bottom_side_ab * polygon_bottom_side_ac) )
  
  polygon_bottom_area = 0.5 * polygon_bottom_side_ab * polygon_bottom_side_ac * np.sin(polygon_bottom_angle)
  
  #"Bottom" segments:

  segment_angle_bottom_circle1 = np.arccos( (2*circle1.r**2 - polygon_bottom_side_bc**2) / (2*circle1.r**2) )
  segment_angle_bottom_circle2 = np.arccos( (2*circle2.r**2 - polygon_bottom_side_ac**2) / (2*circle2.r**2) )
  segment_angle_bottom_circle3 = np.arccos( (2*circle3.r**2 - polygon_bottom_side_ab**2) / (2*circle3.r**2) )

  segment_area_bottom_circle1 = 0.5 * circle1.r**2 * (segment_angle_bottom_circle1 - np.sin(segment_angle_bottom_circle1))
  segment_area_bottom_circle2 = 0.5 * circle2.r**2 * (segment_angle_bottom_circle2 - np.sin(segment_angle_bottom_circle2))
  segment_area_bottom_circle3 = 0.5 * circle3.r**2 * (segment_angle_bottom_circle3 - np.sin(segment_angle_bottom_circle3))
  
  bottom = polygon_bottom_area - segment_area_bottom_circle1 + segment_area_bottom_circle2 + segment_area_bottom_circle3
  
  
  #----------


  green1 = a2 - i2and3 - left
  green2 = a3 - i2and3 - right

  return [[green1, green2, 0, 0],
          [top, right, bottom, left],
          [red, 0, 0, 0]]

#Case 14:
def areas_case14 (circle1, circle2, circle3):
  a1 = area_circle(circle1)
  a2 = area_circle(circle2)
  a3 = area_circle(circle3)

  i1and2 = area_overlap_2circles(circle1, circle2)
  i1and3 = area_overlap_2circles(circle1, circle3)
  i2and3 = area_overlap_2circles(circle2, circle3)

  red = i1and3

  y1 = i1and2 - red
  y2 = i2and3 - red

  green1 = a1 - i1and2
  green4 = a3 - i2and3

  intersections_1and2 = getIntersection_2_circles(circle1, circle2)
  intersections_1and3 = getIntersection_2_circles(circle1, circle3)  
  intersections_2and3 = getIntersection_2_circles(circle2, circle3)

  #Finding g2 (:=top) and g3 (:= bottom) areas using polygon + segments---------------------------------------------

  if (intersections_1and3[0].y > intersections_1and3[1].y):
    polygon_top_vertex_c = intersections_1and3[0]
    polygon_bottom_vertex_c = intersections_1and3[1]
  else:
    polygon_top_vertex_c = intersections_1and3[1]
    polygon_bottom_vertex_c = intersections_1and3[0]

  if (intersections_1and2[0].y > intersections_1and2[1].y):
    polygon_top_vertex_a = intersections_1and2[0]
    polygon_bottom_vertex_a = intersections_1and2[1]
  else:
    polygon_top_vertex_a = intersections_1and2[1]
    polygon_bottom_vertex_a = intersections_1and2[0]

  if (intersections_2and3[0].y > intersections_2and3[1].y):
    polygon_top_vertex_b = intersections_2and3[0]
    polygon_bottom_vertex_b = intersections_2and3[1]
  else:
    polygon_top_vertex_b = intersections_2and3[1]
    polygon_bottom_vertex_b = intersections_2and3[0]

  polygon_top_side_ab = EuclideanDistance(polygon_top_vertex_a, polygon_top_vertex_b)
  polygon_top_side_ac = EuclideanDistance(polygon_top_vertex_a, polygon_top_vertex_c)
  polygon_top_side_bc = EuclideanDistance(polygon_top_vertex_b, polygon_top_vertex_c)
  
  polygon_bottom_side_ab = EuclideanDistance(polygon_bottom_vertex_a, polygon_bottom_vertex_b)
  polygon_bottom_side_ac = EuclideanDistance(polygon_bottom_vertex_a, polygon_bottom_vertex_c)
  polygon_bottom_side_bc = EuclideanDistance(polygon_bottom_vertex_b, polygon_bottom_vertex_c)
  
  #TOP======================================================================

  polygon_top_angle = np.arccos( (polygon_top_side_ac**2 + polygon_top_side_bc**2 - polygon_top_side_ab**2) / (2 * polygon_top_side_ac * polygon_top_side_bc)) #angle ACB
  polygon_top_area = 0.5 * polygon_top_side_ac * polygon_top_side_bc * np.sin(polygon_top_angle)

  top_angle_a_c1_c = np.arccos( (2*circle1.r**2 - polygon_top_side_ac**2) / (2*circle1.r**2) )
  top_segment_1 = 0.5 * circle1.r**2 * (top_angle_a_c1_c - np.sin(top_angle_a_c1_c))

  top_angle_a_c2_b = np.arccos( (2*circle2.r**2 - polygon_top_side_ab**2) / (2*circle2.r**2) )
  top_segment_2 = 0.5 * circle2.r**2 * (top_angle_a_c2_b - np.sin(top_angle_a_c2_b))

  top_angle_c_c2_b = np.arccos( (2*circle3.r**2 - polygon_top_side_bc**2) / (2*circle3.r**2) )
  top_segment_3 = 0.5 * circle3.r**2 * (top_angle_c_c2_b - np.sin(top_angle_c_c2_b))

  green2 = polygon_top_area - top_segment_1 + top_segment_2 - top_segment_3

  #BOTTOM======================================================================

  polygon_bottom_angle = np.arccos( (polygon_bottom_side_ac**2 + polygon_bottom_side_bc**2 - polygon_bottom_side_ab**2) / (2 * polygon_bottom_side_ac * polygon_bottom_side_bc)) #angle ACB
  polygon_bottom_area = 0.5 * polygon_bottom_side_ac * polygon_bottom_side_bc * np.sin(polygon_bottom_angle)

  bottom_angle_a_c1_c = np.arccos( (2*circle1.r**2 - polygon_bottom_side_ac**2) / (2*circle1.r**2) )
  bottom_segment_1 = 0.5 * circle1.r**2 * (bottom_angle_a_c1_c - np.sin(bottom_angle_a_c1_c))

  bottom_angle_a_c2_b = np.arccos( (2*circle2.r**2 - polygon_bottom_side_ab**2) / (2*circle2.r**2) )
  bottom_segment_2 = 0.5 * circle2.r**2 * (bottom_angle_a_c2_b - np.sin(bottom_angle_a_c2_b))

  bottom_angle_c_c2_b = np.arccos( (2*circle3.r**2 - polygon_bottom_side_bc**2) / (2*circle3.r**2) )
  bottom_segment_3 = 0.5 * circle3.r**2 * (bottom_angle_c_c2_b - np.sin(bottom_angle_c_c2_b))

  green3 = polygon_bottom_area - bottom_segment_1 + bottom_segment_2 - bottom_segment_3

  #----------------------------------------------------------------------------------------------

  return [[green1, green2, green3, green4],
          [y1, y2, 0, 0],
          [red, 0, 0, 0]]

#function to combine all the possible cases:
def FindColouredAreas(circle1, circle2, circle3):
  Case = determineOverlapCase(circle1, circle2, circle3)
  print("Case: ", Case[0])

  print("circle_configuration: ", Case[1])

  #---------------------------------------------------------------------------------------------------------------------------------------
  #Configure circles properly

  circle_config = Case[1]

  if circle_config == 1:
    circle1_ = Circle(circle1.x, circle1.y, circle1.r)
    circle2_ = Circle(circle2.x, circle2.y, circle2.r)
    circle3_ = Circle(circle3.x, circle3.y, circle3.r)
  elif circle_config == 2:
    circle1_ = Circle(circle1.x, circle1.y, circle1.r)
    circle2_ = Circle(circle3.x, circle3.y, circle3.r)
    circle3_ = Circle(circle2.x, circle2.y, circle2.r)
  elif circle_config == 3:
    circle1_ = Circle(circle2.x, circle2.y, circle2.r)
    circle2_ = Circle(circle1.x, circle1.y, circle1.r)
    circle3_ = Circle(circle3.x, circle3.y, circle3.r)
  elif circle_config == 4:
    circle1_ = Circle(circle3.x, circle3.y, circle3.r)
    circle2_ = Circle(circle1.x, circle1.y, circle1.r)
    circle3_ = Circle(circle2.x, circle2.y, circle2.r)
  elif circle_config == 5:
    circle1_ = Circle(circle2.x, circle2.y, circle2.r)
    circle2_ = Circle(circle3.x, circle3.y, circle3.r)
    circle3_ = Circle(circle1.x, circle1.y, circle1.r)
  elif circle_config == 6:
    circle1_ = Circle(circle3.x, circle3.y, circle3.r)
    circle2_ = Circle(circle2.x, circle2.y, circle2.r)
    circle3_ = Circle(circle1.x, circle1.y, circle1.r)


  #---------------------------------------------------------------------------------------------------------------------------------------


  if Case[0] == 1:
    coloured_areas = areas_case1(circle1_, circle2_, circle3_)
  elif Case[0] == 2:
    coloured_areas = areas_case2(circle1_, circle2_, circle3_)
  elif Case[0] == 3:
    coloured_areas = areas_case3(circle1_, circle2_, circle3_)
  elif Case[0] == 4:
    coloured_areas = areas_case4(circle1_, circle2_, circle3_)
  elif Case[0] == 5:
    coloured_areas = areas_case5(circle1_, circle2_, circle3_)
  elif Case[0] == 6:
    coloured_areas = areas_case6(circle1_, circle2_, circle3_)
  elif Case[0] == 7:
    coloured_areas = areas_case7(circle1_, circle2_, circle3_)
  elif Case[0] == 8:
    coloured_areas = areas_case8(circle1_, circle2_, circle3_)
  elif Case[0] == 9:
    coloured_areas = areas_case9(circle1_, circle2_, circle3_)
  elif Case[0] == 10:
    coloured_areas = areas_case10(circle1_, circle2_, circle3_)
  elif Case[0] == 11:
    coloured_areas = areas_case11(circle1_, circle2_, circle3_)
  elif Case[0] == 12:
    coloured_areas = areas_case12(circle1_, circle2_, circle3_)
  elif Case[0] == 13:
    coloured_areas = areas_case13(circle1_, circle2_, circle3_)
  elif Case[0] == 14:
    coloured_areas = areas_case14(circle1_, circle2_, circle3_)
  
  print("Green: ", coloured_areas[0])
  print("Yellow: ", coloured_areas[1])
  print("Red: ", coloured_areas[2])

  return coloured_areas

"""# Probability Function"""

def prob_green(area_green):
  if area_green == 0:
    return 0
  else:
    k = 799158.3166
    P = k/area_green/100000

    if P > 0.99:
      P = 0.99

    return P

def prob_yellow(area_yellow):
  if area_yellow == 0:
    return 0
  else:
    k = 207299
    P = k/area_yellow/100000

    if P > 0.99:
      P = 0.99

    return P

def prob_red(area_red):
  if area_red == 0:
    return 0
  else:
    k = 2183363
    P = k/area_red/100000

    if P > 0.99:
      P = 0.99

    return P

def findProbabilities(areas_vector):
  for i in range(len(areas_vector[0])):
    areas_vector[0][i] = prob_green(areas_vector[0][i])
  for i in range(len(areas_vector[1])):
    areas_vector[1][i] = prob_yellow(areas_vector[1][i])
  for i in range(len(areas_vector[2])):
    areas_vector[2][i] = prob_red(areas_vector[2][i])
  return areas_vector

"""# Final function for Backend"""

#------------------------------------------------------------------------------------------------------------------------------------------------------
### Final Algorithm ###
#======================================================================================================================================================

#1.)  Given the coordinates of each of the sensors, create Circle classes with x and y coordinates as the centre. 
#     Convert from Long/Lat to Cartesian if needed.

#2.)  With each sensor having each of the 4 measurements (Temperature, Relative Humidity, Precipitation, Wind Speed), 
#     calculate FWI (Fire Weather Index) metric using calculate_FWI function.

#3.)  Set each sensor's Circle class' radius to be = -11.242 * FWI + 101.88  (km)

#4.)  Pass each Circle to FindColouredAreas function.
#     This returns a 2d array of size 3x4:

#     [[green1, green2, green3, green4],
#     [yellow1, yellow2, yellow3, yellow4],
#     [red1, red2, red3, red4]]

#     Each one corresponding to the area (square km) in that area. 
#     The labelling of the area/region matches the notation used depending on which case (out of 14) the 3 circles intersect. 
#     The case can be printed out too.

#     *Colour code for reference: 
#                 -Green - 1 circle encapsulates the area
#                 -Yellow - 2 circles encapsulates the area
#                 -Red - 3 circles encapsulates the area

#5.)  Pass the 3x4 2d array into findProbabilities function to return the same array but with the probabilities of an active fire in each
#     corresponding region (0 to 1).    

#================================================================================================================================================
#Other side notes:
#  *2 circles will never be concentric and congruent at the same time (same circle) since each sensor will have at least a different sensor
#   so no circles will ever be concentric, even if they are congruent
#     -That being said, this function is for 3 circles, not 2...

#  *code still works when circles are just touching at 1 intersection point. The determineOverlapCase function still returns a Case and just 
#   labels empty spaces with 0.0 area.
#   This may be a Python only thing......

#------------------------------------------------------------------------------------------------------------------------------------------------